<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2019-12-22T18:36:40-05:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">nic-lovin’s blog</title><subtitle></subtitle><entry><title type="html">Patching binary in order to debug child process</title><link href="http://0.0.0.0:4000/reverse/engineering/2019/12/22/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Patching binary in order to debug child process" /><published>2019-12-22T11:39:47-05:00</published><updated>2019-12-22T11:39:47-05:00</updated><id>http://0.0.0.0:4000/reverse/engineering/2019/12/22/welcome-to-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/reverse/engineering/2019/12/22/welcome-to-jekyll.html">&lt;p&gt;I sometimes stumble into binaries that use &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcess&lt;/code&gt;. When debugging with &lt;code class=&quot;highlighter-rouge&quot;&gt;xdbg&lt;/code&gt;, we cannot follow the code excution. In order to debug the binary, I often patch it, then run it and hook to it. I am not an expert in reverse engineering and I am pretty confident that there might be as good or even better ways to do it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TLDR: patch the binary with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xebfe&lt;/code&gt;, execute and attach it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;hooking-createprocess&quot;&gt;Hooking &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcess&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;I have a binary that will create child process using &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt;. I knew this function was called using &lt;code class=&quot;highlighter-rouge&quot;&gt;Process Monitor&lt;/code&gt; from sysinternals (and from &lt;code class=&quot;highlighter-rouge&quot;&gt;Imports&lt;/code&gt; in IDA), so I ran &lt;code class=&quot;highlighter-rouge&quot;&gt;xdbg&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;debug.exe&lt;/code&gt;, put a breakpoint using &lt;code class=&quot;highlighter-rouge&quot;&gt;bp CreateProcessA&lt;/code&gt;. I executed it until it hit the breakpoint.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bp_createprocess.png&quot; alt=&quot;Breakpoint on CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We don’t really want to debug &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt; fonction, so we can step until we get back to the user code (&lt;code class=&quot;highlighter-rouge&quot;&gt;F4&lt;/code&gt;). From there, we can see the stack (or look at registers for x64 binaries) and take a look on how the process was created with its arguments.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/return_createprocess.png&quot; alt=&quot;After CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/stack_createprocess.png&quot; alt=&quot;Stack before CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As it is not a post on how to reverse engineer and find functions in binary, I won’t go in details on how I found the function called when the binary is calling itself with arguments. One could look at the arguments, find the string in the binary and go from there and find where that string is used (&lt;code class=&quot;highlighter-rouge&quot;&gt;xref&lt;/code&gt; in IDA).&lt;/p&gt;

&lt;p&gt;When I found where it all led, the function looked like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/createprocess_function.png&quot; alt=&quot;Function called when CreateProcessA is used&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;and-that-infinite-loop&quot;&gt;And that infinite loop&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xebfe&lt;/code&gt; is 2-byte instruction that creates and infinite loop. Patching the first bytes with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xebfe&lt;/code&gt; with cause the function to run infinitely and that’s perfect for use. We will want to attach the binary as soon as the function is being executed to be able to debug everything.&lt;/p&gt;

&lt;p&gt;In IDA, we can patch bytes using &lt;code class=&quot;highlighter-rouge&quot;&gt;Edit &amp;gt; Patch program &amp;gt; Change Byte&lt;/code&gt;. Save the first bytes and instructions that will be overwritten somewhere with &lt;code class=&quot;highlighter-rouge&quot;&gt;EB FE&lt;/code&gt;. The call graph should change to:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/function_ebfe.png&quot; alt=&quot;Breakpoint on CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We were lucky this time that the first instructions were 1-byte long. If you encounter a multi-byte instructions, you can fill it with &lt;code class=&quot;highlighter-rouge&quot;&gt;0x90&lt;/code&gt;, which is a &lt;code class=&quot;highlighter-rouge&quot;&gt;NOP&lt;/code&gt; instruction.&lt;/p&gt;

&lt;h1 id=&quot;attach-the-patched-binary&quot;&gt;Attach the patched binary&lt;/h1&gt;
&lt;p&gt;Next thing, run the original binary without &lt;code class=&quot;highlighter-rouge&quot;&gt;xdbg&lt;/code&gt; and check at the processes list with &lt;code class=&quot;highlighter-rouge&quot;&gt;Process explorer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ebfe_binary.png&quot; alt=&quot;Breakpoint on CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we right-click, select &lt;code class=&quot;highlighter-rouge&quot;&gt;Properties...&lt;/code&gt;, we should see the same &lt;code class=&quot;highlighter-rouge&quot;&gt;Command line&lt;/code&gt; as in &lt;code class=&quot;highlighter-rouge&quot;&gt;xdbg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, launch &lt;code class=&quot;highlighter-rouge&quot;&gt;xdbg&lt;/code&gt;, attach the binary being ran, &lt;code class=&quot;highlighter-rouge&quot;&gt;File &amp;gt; Attach&lt;/code&gt;, and find the function we earlier modified: &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL + G&lt;/code&gt;, and we should see our &lt;code class=&quot;highlighter-rouge&quot;&gt;EB FE&lt;/code&gt; bytes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ebfe_xdbg.png&quot; alt=&quot;Breakpoint on CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From there, we can to patch again the binary; click on the instruction and press &lt;code class=&quot;highlighter-rouge&quot;&gt;Space&lt;/code&gt;. Change instruction to the orignals one and the function should be as it was at first:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/original_function_xdbg.png&quot; alt=&quot;Breakpoint on CreateProcessA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And you can now debug your function as it was originally.&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;We saw how patching a binary with 2 bytes can help us debugging a binary when it creates a child process:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Find where the &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateProcessA&lt;/code&gt; is used&lt;/li&gt;
  &lt;li&gt;Find what it calls&lt;/li&gt;
  &lt;li&gt;Replace the first bytes of the function with &lt;code class=&quot;highlighter-rouge&quot;&gt;0xebfe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Run the binary, attach to it&lt;/li&gt;
  &lt;li&gt;Find our patched function, patch it again to the original instructions&lt;/li&gt;
  &lt;li&gt;Debug it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using this technique can also bypass some anti-debuggers and might be useful when dealing with malware. However, run malware in a sandbox/virtual machine only!&lt;/p&gt;</content><author><name></name></author><summary type="html">I sometimes stumble into binaries that use CreateProcess. When debugging with xdbg, we cannot follow the code excution. In order to debug the binary, I often patch it, then run it and hook to it. I am not an expert in reverse engineering and I am pretty confident that there might be as good or even better ways to do it.</summary></entry></feed>